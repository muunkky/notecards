rules_version = '2';
service cloud.firestore {
  function isSignedIn() { return request.auth != null; }

  match /databases/{database}/documents {
    // User profiles (self only)
    match /users/{userId} {
      // User documents currently store basic profile (e.g., email) used for collaborator lookup by email.
      // To enable adding collaborators by email, any signed-in user must be able to read another user's
      // profile document (query-by-email requires read access to matching docs). We deliberately scope:
      //  - read: any authenticated user (no sensitive fields should be stored here).
      //  - create/update/delete: only the user themself.
      // If more sensitive data is added in future, move public lookup fields to a separate collection
      // (e.g., userPublic/) and tighten this rule back to self-only.
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow read: if isSignedIn();
      allow update, delete: if isSignedIn() && request.auth.uid == userId;
    }

    // Decks
    match /decks/{deckId} {
      // Create (no helper functions touching parent doc to avoid null issues)
      allow create: if isSignedIn()
        && ('ownerId' in request.resource.data)
        && request.resource.data.ownerId == request.auth.uid
        && ('title' in request.resource.data) && request.resource.data.title is string
        && ('createdAt' in request.resource.data) && request.resource.data.createdAt is timestamp
        && (!('updatedAt' in request.resource.data) || request.resource.data.updatedAt is timestamp)
        && (!('roles' in request.resource.data) || request.resource.data.roles is map)
        && (!('collaboratorIds' in request.resource.data) || request.resource.data.collaboratorIds is list);

      // Helpers (safe: resource exists for read/update/delete)
      function isOwner() { return isSignedIn() && resource.data.ownerId == request.auth.uid; }
      function role(uid) { return (resource.data.roles is map && uid in resource.data.roles) ? resource.data.roles[uid] : null; }
      function isCollab() { return isSignedIn() && (resource.data.roles is map) && (request.auth.uid in resource.data.roles); }

      // Read: owner or any collaborator (viewer/editor)
      allow read: if isOwner() || isCollab();

      // Update logic:
      //  - Owner: may change title, roles, collaboratorIds, updatedAt (cannot change ownerId)
      //  - Editor: may change title (and optionally updatedAt) but not roles/collaboratorIds/ownerId
      allow update: if (
        (
          isOwner() && request.resource.data.ownerId == resource.data.ownerId
        ) || (
          role(request.auth.uid) == 'editor' &&
          request.resource.data.ownerId == resource.data.ownerId &&
          // Editor may NOT alter roles or collaboratorIds
          request.resource.data.roles == resource.data.roles &&
          request.resource.data.collaboratorIds == resource.data.collaboratorIds
        )
      )
        // Immutable fields
        && request.resource.data.createdAt == resource.data.createdAt
        && request.resource.data.ownerId == resource.data.ownerId
        // Type constraints
        && (!('title' in request.resource.data) || request.resource.data.title is string)
        && (!('roles' in request.resource.data) || request.resource.data.roles is map)
        && (!('collaboratorIds' in request.resource.data) || request.resource.data.collaboratorIds is list)
        && (!('updatedAt' in request.resource.data) || request.resource.data.updatedAt is timestamp);

      // Delete: owner only
      allow delete: if isOwner();

      // Cards subcollection
      match /cards/{cardId} {
        // Use explicit (default) database path to avoid emulator warnings about variable names
        function deckDoc() { return get(/databases/(default)/documents/decks/$(deckId)); }
        function deckExists() { return exists(/databases/(default)/documents/decks/$(deckId)); }
        function deckOwner() { return deckExists() && deckDoc().data.ownerId == request.auth.uid; }
        function deckRole(uid) { return (deckExists() && deckDoc().data.roles is map && uid in deckDoc().data.roles) ? deckDoc().data.roles[uid] : null; }
        function deckIsCollab() { return deckExists() && deckDoc().data.roles is map && (request.auth.uid in deckDoc().data.roles); }

        allow read: if deckOwner() || deckIsCollab();
        allow create: if deckOwner() || deckRole(request.auth.uid) == 'editor';
        allow update: if deckOwner() || deckRole(request.auth.uid) == 'editor';
        allow delete: if deckOwner() || deckRole(request.auth.uid) == 'editor';
      }

      // Order snapshots subcollection
      match /orderSnapshots/{snapshotId} {
        function deckDoc() { return get(/databases/(default)/documents/decks/$(deckId)); }
        function deckExists() { return exists(/databases/(default)/documents/decks/$(deckId)); }
        function deckOwner() { return deckExists() && deckDoc().data.ownerId == request.auth.uid; }
        function deckRole(uid) { return (deckExists() && deckDoc().data.roles is map && uid in deckDoc().data.roles) ? deckDoc().data.roles[uid] : null; }
        function deckIsCollab() { return deckExists() && deckDoc().data.roles is map && (request.auth.uid in deckDoc().data.roles); }

        allow read: if deckOwner() || deckIsCollab();
        allow create: if deckOwner() || deckRole(request.auth.uid) == 'editor';
        allow update: if deckOwner() || deckRole(request.auth.uid) == 'editor';
        allow delete: if deckOwner() || deckRole(request.auth.uid) == 'editor';
      }
    }
  }
}
